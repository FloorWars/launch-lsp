/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  Contract,
  ContractTransaction,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import { TypedEventFilter, TypedEvent, TypedListener } from "./commons";

interface IUniswapV3PoolStateInterface extends ethers.utils.Interface {
  functions: {
    "slot0()": FunctionFragment;
    "feeGrowthGlobal0X128()": FunctionFragment;
    "feeGrowthGlobal1X128()": FunctionFragment;
    "protocolFees()": FunctionFragment;
    "liquidity()": FunctionFragment;
    "ticks(int24)": FunctionFragment;
    "tickBitmap(int16)": FunctionFragment;
    "positions(bytes32)": FunctionFragment;
    "observations(uint256)": FunctionFragment;
  };

  encodeFunctionData(functionFragment: "slot0", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "feeGrowthGlobal0X128",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "feeGrowthGlobal1X128",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "protocolFees",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "liquidity", values?: undefined): string;
  encodeFunctionData(functionFragment: "ticks", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "tickBitmap",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "positions",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "observations",
    values: [BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "slot0", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "feeGrowthGlobal0X128",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "feeGrowthGlobal1X128",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "protocolFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "liquidity", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "ticks", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "tickBitmap", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "positions", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "observations",
    data: BytesLike
  ): Result;

  events: {};
}

export class IUniswapV3PoolState extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: IUniswapV3PoolStateInterface;

  functions: {
    /**
     * The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally.
     */
    slot0(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, number, number, number, number, number, boolean] & {
        sqrtPriceX96: BigNumber;
        tick: number;
        observationIndex: number;
        observationCardinality: number;
        observationCardinalityNext: number;
        feeProtocol: number;
        unlocked: boolean;
      }
    >;

    /**
     * The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally.
     */
    "slot0()"(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, number, number, number, number, number, boolean] & {
        sqrtPriceX96: BigNumber;
        tick: number;
        observationIndex: number;
        observationCardinality: number;
        observationCardinalityNext: number;
        feeProtocol: number;
        unlocked: boolean;
      }
    >;

    /**
     * This value can overflow the uint256
     * The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
     */
    feeGrowthGlobal0X128(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * This value can overflow the uint256
     * The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
     */
    "feeGrowthGlobal0X128()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * This value can overflow the uint256
     * The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
     */
    feeGrowthGlobal1X128(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * This value can overflow the uint256
     * The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
     */
    "feeGrowthGlobal1X128()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Protocol fees will never exceed uint128 max in either token
     * The amounts of token0 and token1 that are owed to the protocol
     */
    protocolFees(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { token0: BigNumber; token1: BigNumber }
    >;

    /**
     * Protocol fees will never exceed uint128 max in either token
     * The amounts of token0 and token1 that are owed to the protocol
     */
    "protocolFees()"(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { token0: BigNumber; token1: BigNumber }
    >;

    /**
     * This value has no relationship to the total liquidity across all ticks
     * The currently in range liquidity available to the pool
     */
    liquidity(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * This value has no relationship to the total liquidity across all ticks
     * The currently in range liquidity available to the pool
     */
    "liquidity()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Look up information about a specific tick in the pool
     * @param tick The tick to look up
     */
    ticks(
      tick: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        boolean
      ] & {
        liquidityGross: BigNumber;
        liquidityNet: BigNumber;
        feeGrowthOutside0X128: BigNumber;
        feeGrowthOutside1X128: BigNumber;
        tickCumulativeOutside: BigNumber;
        secondsPerLiquidityOutsideX128: BigNumber;
        secondsOutside: number;
        initialized: boolean;
      }
    >;

    /**
     * Look up information about a specific tick in the pool
     * @param tick The tick to look up
     */
    "ticks(int24)"(
      tick: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        boolean
      ] & {
        liquidityGross: BigNumber;
        liquidityNet: BigNumber;
        feeGrowthOutside0X128: BigNumber;
        feeGrowthOutside1X128: BigNumber;
        tickCumulativeOutside: BigNumber;
        secondsPerLiquidityOutsideX128: BigNumber;
        secondsOutside: number;
        initialized: boolean;
      }
    >;

    /**
     * Returns 256 packed tick initialized boolean values. See TickBitmap for more information
     */
    tickBitmap(
      wordPosition: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Returns 256 packed tick initialized boolean values. See TickBitmap for more information
     */
    "tickBitmap(int16)"(
      wordPosition: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Returns the information about a position by the position's key
     * @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
     */
    positions(
      key: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        _liquidity: BigNumber;
        feeGrowthInside0LastX128: BigNumber;
        feeGrowthInside1LastX128: BigNumber;
        tokensOwed0: BigNumber;
        tokensOwed1: BigNumber;
      }
    >;

    /**
     * Returns the information about a position by the position's key
     * @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
     */
    "positions(bytes32)"(
      key: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        _liquidity: BigNumber;
        feeGrowthInside0LastX128: BigNumber;
        feeGrowthInside1LastX128: BigNumber;
        tokensOwed0: BigNumber;
        tokensOwed1: BigNumber;
      }
    >;

    /**
     * You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array.
     * Returns data about a specific observation index
     * @param index The element of the observations array to fetch
     */
    observations(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, boolean] & {
        blockTimestamp: number;
        tickCumulative: BigNumber;
        secondsPerLiquidityCumulativeX128: BigNumber;
        initialized: boolean;
      }
    >;

    /**
     * You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array.
     * Returns data about a specific observation index
     * @param index The element of the observations array to fetch
     */
    "observations(uint256)"(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, boolean] & {
        blockTimestamp: number;
        tickCumulative: BigNumber;
        secondsPerLiquidityCumulativeX128: BigNumber;
        initialized: boolean;
      }
    >;
  };

  /**
   * The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally.
   */
  slot0(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, number, number, number, number, number, boolean] & {
      sqrtPriceX96: BigNumber;
      tick: number;
      observationIndex: number;
      observationCardinality: number;
      observationCardinalityNext: number;
      feeProtocol: number;
      unlocked: boolean;
    }
  >;

  /**
   * The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally.
   */
  "slot0()"(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, number, number, number, number, number, boolean] & {
      sqrtPriceX96: BigNumber;
      tick: number;
      observationIndex: number;
      observationCardinality: number;
      observationCardinalityNext: number;
      feeProtocol: number;
      unlocked: boolean;
    }
  >;

  /**
   * This value can overflow the uint256
   * The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
   */
  feeGrowthGlobal0X128(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * This value can overflow the uint256
   * The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
   */
  "feeGrowthGlobal0X128()"(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * This value can overflow the uint256
   * The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
   */
  feeGrowthGlobal1X128(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * This value can overflow the uint256
   * The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
   */
  "feeGrowthGlobal1X128()"(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Protocol fees will never exceed uint128 max in either token
   * The amounts of token0 and token1 that are owed to the protocol
   */
  protocolFees(
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber] & { token0: BigNumber; token1: BigNumber }>;

  /**
   * Protocol fees will never exceed uint128 max in either token
   * The amounts of token0 and token1 that are owed to the protocol
   */
  "protocolFees()"(
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber] & { token0: BigNumber; token1: BigNumber }>;

  /**
   * This value has no relationship to the total liquidity across all ticks
   * The currently in range liquidity available to the pool
   */
  liquidity(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * This value has no relationship to the total liquidity across all ticks
   * The currently in range liquidity available to the pool
   */
  "liquidity()"(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Look up information about a specific tick in the pool
   * @param tick The tick to look up
   */
  ticks(
    tick: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      number,
      boolean
    ] & {
      liquidityGross: BigNumber;
      liquidityNet: BigNumber;
      feeGrowthOutside0X128: BigNumber;
      feeGrowthOutside1X128: BigNumber;
      tickCumulativeOutside: BigNumber;
      secondsPerLiquidityOutsideX128: BigNumber;
      secondsOutside: number;
      initialized: boolean;
    }
  >;

  /**
   * Look up information about a specific tick in the pool
   * @param tick The tick to look up
   */
  "ticks(int24)"(
    tick: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      number,
      boolean
    ] & {
      liquidityGross: BigNumber;
      liquidityNet: BigNumber;
      feeGrowthOutside0X128: BigNumber;
      feeGrowthOutside1X128: BigNumber;
      tickCumulativeOutside: BigNumber;
      secondsPerLiquidityOutsideX128: BigNumber;
      secondsOutside: number;
      initialized: boolean;
    }
  >;

  /**
   * Returns 256 packed tick initialized boolean values. See TickBitmap for more information
   */
  tickBitmap(
    wordPosition: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Returns 256 packed tick initialized boolean values. See TickBitmap for more information
   */
  "tickBitmap(int16)"(
    wordPosition: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Returns the information about a position by the position's key
   * @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
   */
  positions(
    key: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
      _liquidity: BigNumber;
      feeGrowthInside0LastX128: BigNumber;
      feeGrowthInside1LastX128: BigNumber;
      tokensOwed0: BigNumber;
      tokensOwed1: BigNumber;
    }
  >;

  /**
   * Returns the information about a position by the position's key
   * @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
   */
  "positions(bytes32)"(
    key: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
      _liquidity: BigNumber;
      feeGrowthInside0LastX128: BigNumber;
      feeGrowthInside1LastX128: BigNumber;
      tokensOwed0: BigNumber;
      tokensOwed1: BigNumber;
    }
  >;

  /**
   * You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array.
   * Returns data about a specific observation index
   * @param index The element of the observations array to fetch
   */
  observations(
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [number, BigNumber, BigNumber, boolean] & {
      blockTimestamp: number;
      tickCumulative: BigNumber;
      secondsPerLiquidityCumulativeX128: BigNumber;
      initialized: boolean;
    }
  >;

  /**
   * You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array.
   * Returns data about a specific observation index
   * @param index The element of the observations array to fetch
   */
  "observations(uint256)"(
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [number, BigNumber, BigNumber, boolean] & {
      blockTimestamp: number;
      tickCumulative: BigNumber;
      secondsPerLiquidityCumulativeX128: BigNumber;
      initialized: boolean;
    }
  >;

  callStatic: {
    /**
     * The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally.
     */
    slot0(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, number, number, number, number, number, boolean] & {
        sqrtPriceX96: BigNumber;
        tick: number;
        observationIndex: number;
        observationCardinality: number;
        observationCardinalityNext: number;
        feeProtocol: number;
        unlocked: boolean;
      }
    >;

    /**
     * The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally.
     */
    "slot0()"(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, number, number, number, number, number, boolean] & {
        sqrtPriceX96: BigNumber;
        tick: number;
        observationIndex: number;
        observationCardinality: number;
        observationCardinalityNext: number;
        feeProtocol: number;
        unlocked: boolean;
      }
    >;

    /**
     * This value can overflow the uint256
     * The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
     */
    feeGrowthGlobal0X128(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This value can overflow the uint256
     * The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
     */
    "feeGrowthGlobal0X128()"(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This value can overflow the uint256
     * The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
     */
    feeGrowthGlobal1X128(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This value can overflow the uint256
     * The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
     */
    "feeGrowthGlobal1X128()"(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Protocol fees will never exceed uint128 max in either token
     * The amounts of token0 and token1 that are owed to the protocol
     */
    protocolFees(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { token0: BigNumber; token1: BigNumber }
    >;

    /**
     * Protocol fees will never exceed uint128 max in either token
     * The amounts of token0 and token1 that are owed to the protocol
     */
    "protocolFees()"(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { token0: BigNumber; token1: BigNumber }
    >;

    /**
     * This value has no relationship to the total liquidity across all ticks
     * The currently in range liquidity available to the pool
     */
    liquidity(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This value has no relationship to the total liquidity across all ticks
     * The currently in range liquidity available to the pool
     */
    "liquidity()"(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Look up information about a specific tick in the pool
     * @param tick The tick to look up
     */
    ticks(
      tick: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        boolean
      ] & {
        liquidityGross: BigNumber;
        liquidityNet: BigNumber;
        feeGrowthOutside0X128: BigNumber;
        feeGrowthOutside1X128: BigNumber;
        tickCumulativeOutside: BigNumber;
        secondsPerLiquidityOutsideX128: BigNumber;
        secondsOutside: number;
        initialized: boolean;
      }
    >;

    /**
     * Look up information about a specific tick in the pool
     * @param tick The tick to look up
     */
    "ticks(int24)"(
      tick: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        boolean
      ] & {
        liquidityGross: BigNumber;
        liquidityNet: BigNumber;
        feeGrowthOutside0X128: BigNumber;
        feeGrowthOutside1X128: BigNumber;
        tickCumulativeOutside: BigNumber;
        secondsPerLiquidityOutsideX128: BigNumber;
        secondsOutside: number;
        initialized: boolean;
      }
    >;

    /**
     * Returns 256 packed tick initialized boolean values. See TickBitmap for more information
     */
    tickBitmap(
      wordPosition: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns 256 packed tick initialized boolean values. See TickBitmap for more information
     */
    "tickBitmap(int16)"(
      wordPosition: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the information about a position by the position's key
     * @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
     */
    positions(
      key: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        _liquidity: BigNumber;
        feeGrowthInside0LastX128: BigNumber;
        feeGrowthInside1LastX128: BigNumber;
        tokensOwed0: BigNumber;
        tokensOwed1: BigNumber;
      }
    >;

    /**
     * Returns the information about a position by the position's key
     * @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
     */
    "positions(bytes32)"(
      key: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        _liquidity: BigNumber;
        feeGrowthInside0LastX128: BigNumber;
        feeGrowthInside1LastX128: BigNumber;
        tokensOwed0: BigNumber;
        tokensOwed1: BigNumber;
      }
    >;

    /**
     * You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array.
     * Returns data about a specific observation index
     * @param index The element of the observations array to fetch
     */
    observations(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, boolean] & {
        blockTimestamp: number;
        tickCumulative: BigNumber;
        secondsPerLiquidityCumulativeX128: BigNumber;
        initialized: boolean;
      }
    >;

    /**
     * You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array.
     * Returns data about a specific observation index
     * @param index The element of the observations array to fetch
     */
    "observations(uint256)"(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, boolean] & {
        blockTimestamp: number;
        tickCumulative: BigNumber;
        secondsPerLiquidityCumulativeX128: BigNumber;
        initialized: boolean;
      }
    >;
  };

  filters: {};

  estimateGas: {
    /**
     * The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally.
     */
    slot0(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally.
     */
    "slot0()"(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This value can overflow the uint256
     * The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
     */
    feeGrowthGlobal0X128(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This value can overflow the uint256
     * The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
     */
    "feeGrowthGlobal0X128()"(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This value can overflow the uint256
     * The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
     */
    feeGrowthGlobal1X128(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This value can overflow the uint256
     * The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
     */
    "feeGrowthGlobal1X128()"(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Protocol fees will never exceed uint128 max in either token
     * The amounts of token0 and token1 that are owed to the protocol
     */
    protocolFees(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Protocol fees will never exceed uint128 max in either token
     * The amounts of token0 and token1 that are owed to the protocol
     */
    "protocolFees()"(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This value has no relationship to the total liquidity across all ticks
     * The currently in range liquidity available to the pool
     */
    liquidity(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This value has no relationship to the total liquidity across all ticks
     * The currently in range liquidity available to the pool
     */
    "liquidity()"(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Look up information about a specific tick in the pool
     * @param tick The tick to look up
     */
    ticks(tick: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Look up information about a specific tick in the pool
     * @param tick The tick to look up
     */
    "ticks(int24)"(
      tick: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns 256 packed tick initialized boolean values. See TickBitmap for more information
     */
    tickBitmap(
      wordPosition: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns 256 packed tick initialized boolean values. See TickBitmap for more information
     */
    "tickBitmap(int16)"(
      wordPosition: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the information about a position by the position's key
     * @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
     */
    positions(key: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the information about a position by the position's key
     * @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
     */
    "positions(bytes32)"(
      key: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array.
     * Returns data about a specific observation index
     * @param index The element of the observations array to fetch
     */
    observations(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array.
     * Returns data about a specific observation index
     * @param index The element of the observations array to fetch
     */
    "observations(uint256)"(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally.
     */
    slot0(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally.
     */
    "slot0()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * This value can overflow the uint256
     * The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
     */
    feeGrowthGlobal0X128(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * This value can overflow the uint256
     * The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
     */
    "feeGrowthGlobal0X128()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * This value can overflow the uint256
     * The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
     */
    feeGrowthGlobal1X128(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * This value can overflow the uint256
     * The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
     */
    "feeGrowthGlobal1X128()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Protocol fees will never exceed uint128 max in either token
     * The amounts of token0 and token1 that are owed to the protocol
     */
    protocolFees(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Protocol fees will never exceed uint128 max in either token
     * The amounts of token0 and token1 that are owed to the protocol
     */
    "protocolFees()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * This value has no relationship to the total liquidity across all ticks
     * The currently in range liquidity available to the pool
     */
    liquidity(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * This value has no relationship to the total liquidity across all ticks
     * The currently in range liquidity available to the pool
     */
    "liquidity()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Look up information about a specific tick in the pool
     * @param tick The tick to look up
     */
    ticks(
      tick: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Look up information about a specific tick in the pool
     * @param tick The tick to look up
     */
    "ticks(int24)"(
      tick: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns 256 packed tick initialized boolean values. See TickBitmap for more information
     */
    tickBitmap(
      wordPosition: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns 256 packed tick initialized boolean values. See TickBitmap for more information
     */
    "tickBitmap(int16)"(
      wordPosition: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the information about a position by the position's key
     * @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
     */
    positions(
      key: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the information about a position by the position's key
     * @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
     */
    "positions(bytes32)"(
      key: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array.
     * Returns data about a specific observation index
     * @param index The element of the observations array to fetch
     */
    observations(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array.
     * Returns data about a specific observation index
     * @param index The element of the observations array to fetch
     */
    "observations(uint256)"(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
