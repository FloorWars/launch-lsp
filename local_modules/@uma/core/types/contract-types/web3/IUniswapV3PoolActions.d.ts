/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import BN from "bn.js";
import { ContractOptions } from "web3-eth-contract";
import { EventLog } from "web3-core";
import { EventEmitter } from "events";
import {
  Callback,
  PayableTransactionObject,
  NonPayableTransactionObject,
  BlockType,
  ContractEventLog,
  BaseContract,
} from "./types";

interface EventOptions {
  filter?: object;
  fromBlock?: BlockType;
  topics?: string[];
}

export interface IUniswapV3PoolActions extends BaseContract {
  constructor(
    jsonInterface: any[],
    address?: string,
    options?: ContractOptions
  ): IUniswapV3PoolActions;
  clone(): IUniswapV3PoolActions;
  methods: {
    /**
     * Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value
     * Sets the initial price for the pool
     * @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96
     */
    initialize(
      sqrtPriceX96: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends on tickLower, tickUpper, the amount of liquidity, and the current price.
     * Adds liquidity for the given recipient/tickLower/tickUpper position
     * @param amount The amount of liquidity to mint
     * @param data Any data that should be passed through to the callback
     * @param recipient The address for which the liquidity will be created
     * @param tickLower The lower tick of the position in which to add liquidity
     * @param tickUpper The upper tick of the position in which to add liquidity
     */
    mint(
      recipient: string,
      tickLower: number | string | BN,
      tickUpper: number | string | BN,
      amount: number | string | BN,
      data: string | number[]
    ): NonPayableTransactionObject<{
      amount0: string;
      amount1: string;
      0: string;
      1: string;
    }>;

    /**
     * Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity. Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
     * Collects tokens owed to a position
     * @param amount0Requested How much token0 should be withdrawn from the fees owed
     * @param amount1Requested How much token1 should be withdrawn from the fees owed
     * @param recipient The address which should receive the fees collected
     * @param tickLower The lower tick of the position for which to collect fees
     * @param tickUpper The upper tick of the position for which to collect fees
     */
    collect(
      recipient: string,
      tickLower: number | string | BN,
      tickUpper: number | string | BN,
      amount0Requested: number | string | BN,
      amount1Requested: number | string | BN
    ): NonPayableTransactionObject<{
      amount0: string;
      amount1: string;
      0: string;
      1: string;
    }>;

    /**
     * Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0Fees must be collected separately via a call to #collect
     * Burn liquidity from the sender and account tokens owed for the liquidity to the position
     * @param amount How much liquidity to burn
     * @param tickLower The lower tick of the position for which to burn liquidity
     * @param tickUpper The upper tick of the position for which to burn liquidity
     */
    burn(
      tickLower: number | string | BN,
      tickUpper: number | string | BN,
      amount: number | string | BN
    ): NonPayableTransactionObject<{
      amount0: string;
      amount1: string;
      0: string;
      1: string;
    }>;

    /**
     * The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
     * Swap token0 for token1, or token1 for token0
     * @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
     * @param data Any data to be passed through to the callback
     * @param recipient The address to receive the output of the swap
     * @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap
     * @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
     */
    swap(
      recipient: string,
      zeroForOne: boolean,
      amountSpecified: number | string | BN,
      sqrtPriceLimitX96: number | string | BN,
      data: string | number[]
    ): NonPayableTransactionObject<{
      amount0: string;
      amount1: string;
      0: string;
      1: string;
    }>;

    /**
     * The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallbackCan be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling with 0 amount{0,1} and sending the donation amount(s) from the callback
     * Receive token0 and/or token1 and pay it back, plus a fee, in the callback
     * @param amount0 The amount of token0 to send
     * @param amount1 The amount of token1 to send
     * @param data Any data to be passed through to the callback
     * @param recipient The address which will receive the token0 and token1 amounts
     */
    flash(
      recipient: string,
      amount0: number | string | BN,
      amount1: number | string | BN,
      data: string | number[]
    ): NonPayableTransactionObject<void>;

    /**
     * This method is no-op if the pool already has an observationCardinalityNext greater than or equal to the input observationCardinalityNext.
     * Increase the maximum number of price and liquidity observations that this pool will store
     * @param observationCardinalityNext The desired minimum number of observations for the pool to store
     */
    increaseObservationCardinalityNext(
      observationCardinalityNext: number | string | BN
    ): NonPayableTransactionObject<void>;
  };
  events: {
    allEvents(options?: EventOptions, cb?: Callback<EventLog>): EventEmitter;
  };
}
