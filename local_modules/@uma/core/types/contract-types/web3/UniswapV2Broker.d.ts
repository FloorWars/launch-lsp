/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import BN from "bn.js";
import { ContractOptions } from "web3-eth-contract";
import { EventLog } from "web3-core";
import { EventEmitter } from "events";
import {
  Callback,
  PayableTransactionObject,
  NonPayableTransactionObject,
  BlockType,
  ContractEventLog,
  BaseContract,
} from "./types";

interface EventOptions {
  filter?: object;
  fromBlock?: BlockType;
  topics?: string[];
}

export interface UniswapV2Broker extends BaseContract {
  constructor(
    jsonInterface: any[],
    address?: string,
    options?: ContractOptions
  ): UniswapV2Broker;
  clone(): UniswapV2Broker;
  methods: {
    /**
     * True price is expressed in the ratio of token A to token B.The caller must approve this contract to spend whichever token is intended to be swapped.
     * Swaps an amount of either token such that the trade results in the uniswap pair's price being as close as possible to the truePrice.
     * @param deadline to limit when the trade can execute. If the tx is mined after this timestamp then revert.
     * @param maxSpendTokens array of unit to represent the max to spend in the two tokens.
     * @param swappedTokens array of addresses which are to be swapped. The order does not matter as the function will figure out which tokens need to be exchanged to move the market to the desired "true" price.
     * @param to recipient of the trade proceeds.
     * @param tradingAsEOA bool to indicate if the UniswapV2Broker is being called by a DSProxy or an EOA.
     * @param truePriceTokens array of unit used to represent the true price. 0th value is the numerator of the true price and the 1st value is the the denominator of the true price.
     * @param uniswapFactory address of the uniswap factory used to fetch current pair reserves.
     * @param uniswapRouter address of the uniswap router used to facilitate trades.
     */
    swapToPrice(
      tradingAsEOA: boolean,
      uniswapRouter: string,
      uniswapFactory: string,
      swappedTokens: string[],
      truePriceTokens: (number | string | BN)[],
      maxSpendTokens: (number | string | BN)[],
      to: string,
      deadline: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * Note that this method uses the Babylonian square root method which has a small margin of error which will result in a small over or under estimation on the size of the trade needed.
     * Given the "true" price a token (represented by truePriceTokenA/truePriceTokenB) and the reservers in the uniswap pair, calculate: a) the direction of trade (aToB) and b) the amount needed to trade (amountIn) to move the pool price to be equal to the true price.
     * @param reserveA number of token A in the pair reserves
     * @param reserveB number of token B in the pair reserves
     * @param truePriceTokenA the nominator of the true price.
     * @param truePriceTokenB the denominator of the true price.
     */
    computeTradeToMoveMarket(
      truePriceTokenA: number | string | BN,
      truePriceTokenB: number | string | BN,
      reserveA: number | string | BN,
      reserveB: number | string | BN
    ): NonPayableTransactionObject<{
      aToB: boolean;
      amountIn: string;
      0: boolean;
      1: string;
    }>;

    getReserves(
      factory: string,
      tokenA: string,
      tokenB: string
    ): NonPayableTransactionObject<{
      reserveA: string;
      reserveB: string;
      0: string;
      1: string;
    }>;
  };
  events: {
    allEvents(options?: EventOptions, cb?: Callback<EventLog>): EventEmitter;
  };
}
