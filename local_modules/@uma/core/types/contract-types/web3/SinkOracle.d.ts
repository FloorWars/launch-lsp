/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import BN from "bn.js";
import { ContractOptions } from "web3-eth-contract";
import { EventLog } from "web3-core";
import { EventEmitter } from "events";
import {
  Callback,
  PayableTransactionObject,
  NonPayableTransactionObject,
  BlockType,
  ContractEventLog,
  BaseContract,
} from "./types";

interface EventOptions {
  filter?: object;
  fromBlock?: BlockType;
  topics?: string[];
}

export type PriceRequestAdded = ContractEventLog<{
  chainID: string;
  identifier: string;
  time: string;
  ancillaryData: string;
  0: string;
  1: string;
  2: string;
  3: string;
}>;
export type PushedPrice = ContractEventLog<{
  chainID: string;
  identifier: string;
  time: string;
  ancillaryData: string;
  price: string;
  0: string;
  1: string;
  2: string;
  3: string;
  4: string;
}>;

export interface SinkOracle extends BaseContract {
  constructor(
    jsonInterface: any[],
    address?: string,
    options?: ContractOptions
  ): SinkOracle;
  clone(): SinkOracle;
  methods: {
    currentChainID(): NonPayableTransactionObject<string>;

    destinationChainID(): NonPayableTransactionObject<string>;

    finder(): NonPayableTransactionObject<string>;

    /**
     * Can be called only by a Registered contract that is allowed to make DVM price requests. Will mark this price request as Requested, and therefore able to receive the ultimate price resolution data, and also calls the local Bridge's deposit() method which will emit a Deposit event in order to signal to an off-chain relayer to begin the cross-chain process.
     * This is the first method that should be called in order to bridge a price request to Mainnet.
     * @param ancillaryData extra data of price request.
     * @param identifier Identifier of price request.
     * @param time Timestamp of price request.
     */
    requestPrice(
      identifier: string | number[],
      time: number | string | BN,
      ancillaryData: string | number[]
    ): NonPayableTransactionObject<void>;

    /**
     * This method should basically check that the `Bridge.deposit()` was triggered by a valid price request, specifically one that has not resolved yet and was called by a registered contract. Without this check, `Bridge.deposit()` could be called by non-registered contracts to make price requests to the DVM.
     * This method will ultimately be called after `requestPrice` calls `Bridge.deposit()`, which will call `GenericHandler.deposit()` and ultimately this method.
     * @param ancillaryData extra data of price request.
     * @param identifier Identifier of price request.
     * @param sinkChainID Chain ID for this contract.
     * @param time Timestamp of price request.
     */
    validateDeposit(
      sinkChainID: number | string | BN,
      identifier: string | number[],
      time: number | string | BN,
      ancillaryData: string | number[]
    ): NonPayableTransactionObject<void>;

    /**
     * This method should publish the price data for a requested price request. If this method fails for some reason, then it means that the price was never requested. Can only be called by the `GenericHandler`.
     * This method will ultimately be called after a `publishPrice` has been bridged cross-chain from Mainnet to this network via an off-chain relayer. The relayer will call `Bridge.executeProposal` on this local network, which call `GenericHandler.executeProposal()` and ultimately this method.
     * @param ancillaryData extra data of price request to resolve.
     * @param identifier Identifier of price request to resolve.
     * @param price Price to publish to this oracle.
     * @param sinkChainID Chain ID for this contract.
     * @param time Timestamp of price request to resolve.
     */
    executePublishPrice(
      sinkChainID: number | string | BN,
      identifier: string | number[],
      time: number | string | BN,
      ancillaryData: string | number[],
      price: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * Returns whether a price has resolved for the request.
     * @param ancillaryData extra data of price request.
     * @param identifier Identifier of price request.
     * @param time Timestamp of price request
     */
    hasPrice(
      identifier: string | number[],
      time: number | string | BN,
      ancillaryData: string | number[]
    ): NonPayableTransactionObject<boolean>;

    /**
     * Reverts if price is not available.
     * Returns resolved price for the request.
     * @param ancillaryData extra data of price request.
     * @param identifier Identifier of price request.
     * @param time Timestamp of price request
     */
    getPrice(
      identifier: string | number[],
      time: number | string | BN,
      ancillaryData: string | number[]
    ): NonPayableTransactionObject<string>;

    /**
     * More details about Resource ID's here: https://chainbridge.chainsafe.io/spec/#resource-id
     * Convenience method to get cross-chain Bridge resource ID linking this contract with the SourceOracle.
     */
    getResourceId(): NonPayableTransactionObject<string>;

    /**
     * GenericHandler.deposit() expects data to be formatted as:     len(data)                              uint256     bytes  0  - 32     data                                   bytes       bytes  32 - END
     * This helper method is useful for calling Bridge.deposit().
     * @param ancillaryData extra data of price request.
     * @param chainID Chain ID for this contract.
     * @param identifier Identifier of price request.
     * @param time Timestamp of price request.
     */
    formatMetadata(
      chainID: number | string | BN,
      identifier: string | number[],
      time: number | string | BN,
      ancillaryData: string | number[]
    ): NonPayableTransactionObject<string>;
  };
  events: {
    PriceRequestAdded(cb?: Callback<PriceRequestAdded>): EventEmitter;
    PriceRequestAdded(
      options?: EventOptions,
      cb?: Callback<PriceRequestAdded>
    ): EventEmitter;

    PushedPrice(cb?: Callback<PushedPrice>): EventEmitter;
    PushedPrice(
      options?: EventOptions,
      cb?: Callback<PushedPrice>
    ): EventEmitter;

    allEvents(options?: EventOptions, cb?: Callback<EventLog>): EventEmitter;
  };

  once(event: "PriceRequestAdded", cb: Callback<PriceRequestAdded>): void;
  once(
    event: "PriceRequestAdded",
    options: EventOptions,
    cb: Callback<PriceRequestAdded>
  ): void;

  once(event: "PushedPrice", cb: Callback<PushedPrice>): void;
  once(
    event: "PushedPrice",
    options: EventOptions,
    cb: Callback<PushedPrice>
  ): void;
}
