/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import BN from "bn.js";
import { EventData, PastEventOptions } from "web3-eth-contract";

export interface MerkleDistributorContract
  extends Truffle.Contract<MerkleDistributorInstance> {
  "new"(meta?: Truffle.TransactionDetails): Promise<MerkleDistributorInstance>;
}

export interface Claimed {
  name: "Claimed";
  args: {
    caller: string;
    windowIndex: BN;
    account: string;
    accountIndex: BN;
    amount: BN;
    rewardToken: string;
    0: string;
    1: BN;
    2: string;
    3: BN;
    4: BN;
    5: string;
  };
}

export interface CreatedWindow {
  name: "CreatedWindow";
  args: {
    windowIndex: BN;
    rewardsDeposited: BN;
    rewardToken: string;
    owner: string;
    0: BN;
    1: BN;
    2: string;
    3: string;
  };
}

export interface DeleteWindow {
  name: "DeleteWindow";
  args: {
    windowIndex: BN;
    owner: string;
    0: BN;
    1: string;
  };
}

export interface OwnershipTransferred {
  name: "OwnershipTransferred";
  args: {
    previousOwner: string;
    newOwner: string;
    0: string;
    1: string;
  };
}

export interface WithdrawRewards {
  name: "WithdrawRewards";
  args: {
    owner: string;
    amount: BN;
    currency: string;
    0: string;
    1: BN;
    2: string;
  };
}

type AllEvents =
  | Claimed
  | CreatedWindow
  | DeleteWindow
  | OwnershipTransferred
  | WithdrawRewards;

export interface MerkleDistributorInstance extends Truffle.ContractInstance {
  merkleWindows(
    arg0: number | BN | string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<{ 0: string; 1: string; 2: string }>;

  nextCreatedIndex(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  /**
   * Returns the address of the current owner.
   */
  owner(txDetails?: Truffle.TransactionDetails): Promise<string>;

  /**
   * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
   */
  renounceOwnership: {
    (txDetails?: Truffle.TransactionDetails): Promise<
      Truffle.TransactionResponse<AllEvents>
    >;
    call(txDetails?: Truffle.TransactionDetails): Promise<void>;
    sendTransaction(txDetails?: Truffle.TransactionDetails): Promise<string>;
    estimateGas(txDetails?: Truffle.TransactionDetails): Promise<number>;
  };

  /**
   * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
   */
  transferOwnership: {
    (newOwner: string, txDetails?: Truffle.TransactionDetails): Promise<
      Truffle.TransactionResponse<AllEvents>
    >;
    call(
      newOwner: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      newOwner: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      newOwner: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Set merkle root for the next available window index and seed allocations.Callable only by owner of this contract. Caller must have approved this contract to transfer      `rewardsToDeposit` amount of `rewardToken` or this call will fail. Importantly, we assume that the      owner of this contract correctly chooses an amount `rewardsToDeposit` that is sufficient to cover all      claims within the `merkleRoot`. Otherwise, a race condition can be created. This situation can occur      because we do not segregate reward balances by window, for code simplicity purposes.      (If `rewardsToDeposit` is purposefully insufficient to payout all claims, then the admin must      subsequently transfer in rewards or the following situation can occur).      Example race situation:          - Window 1 Tree: Owner sets `rewardsToDeposit=100` and insert proofs that give claimant A 50 tokens and            claimant B 51 tokens. The owner has made an error by not setting the `rewardsToDeposit` correctly to 101.          - Window 2 Tree: Owner sets `rewardsToDeposit=1` and insert proofs that give claimant A 1 token. The owner            correctly set `rewardsToDeposit` this time.          - At this point contract owns 100 + 1 = 101 tokens. Now, imagine the following sequence:              (1) Claimant A claims 50 tokens for Window 1, contract now has 101 - 50 = 51 tokens.              (2) Claimant B claims 51 tokens for Window 1, contract now has 51 - 51 = 0 tokens.              (3) Claimant A tries to claim 1 token for Window 2 but fails because contract has 0 tokens.          - In summary, the contract owner created a race for step(2) and step(3) in which the first claim would            succeed and the second claim would fail, even though both claimants would expect their claims to succeed.
   * @param ipfsHash hash of IPFS object, conveniently stored for clients
   * @param merkleRoot merkle root describing allocation.
   * @param rewardToken ERC20 reward token.
   * @param rewardsToDeposit amount of rewards to deposit to seed this allocation.
   */
  setWindow: {
    (
      rewardsToDeposit: number | BN | string,
      rewardToken: string,
      merkleRoot: string,
      ipfsHash: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      rewardsToDeposit: number | BN | string,
      rewardToken: string,
      merkleRoot: string,
      ipfsHash: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      rewardsToDeposit: number | BN | string,
      rewardToken: string,
      merkleRoot: string,
      ipfsHash: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      rewardsToDeposit: number | BN | string,
      rewardToken: string,
      merkleRoot: string,
      ipfsHash: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Callable only by owner. Likely to be followed by a withdrawRewards call to clear contract state.
   * Delete merkle root at window index.
   * @param windowIndex merkle root index to delete.
   */
  deleteWindow: {
    (
      windowIndex: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      windowIndex: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      windowIndex: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      windowIndex: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Callable only by owner.
   * Emergency method that transfers rewards out of the contract if the contract was configured improperly.
   * @param amount amount of rewards to withdraw.
   * @param rewardCurrency rewards to withdraw from contract.
   */
  withdrawRewards: {
    (
      rewardCurrency: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      rewardCurrency: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      rewardCurrency: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      rewardCurrency: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  claimMulti: {
    (
      claims: {
        windowIndex: number | BN | string;
        amount: number | BN | string;
        accountIndex: number | BN | string;
        account: string;
        merkleProof: string[];
      }[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      claims: {
        windowIndex: number | BN | string;
        amount: number | BN | string;
        accountIndex: number | BN | string;
        account: string;
        merkleProof: string[];
      }[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      claims: {
        windowIndex: number | BN | string;
        amount: number | BN | string;
        accountIndex: number | BN | string;
        account: string;
        merkleProof: string[];
      }[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      claims: {
        windowIndex: number | BN | string;
        amount: number | BN | string;
        accountIndex: number | BN | string;
        account: string;
        merkleProof: string[];
      }[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  claim: {
    (
      _claim: {
        windowIndex: number | BN | string;
        amount: number | BN | string;
        accountIndex: number | BN | string;
        account: string;
        merkleProof: string[];
      },
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      _claim: {
        windowIndex: number | BN | string;
        amount: number | BN | string;
        accountIndex: number | BN | string;
        account: string;
        merkleProof: string[];
      },
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      _claim: {
        windowIndex: number | BN | string;
        amount: number | BN | string;
        accountIndex: number | BN | string;
        account: string;
        merkleProof: string[];
      },
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      _claim: {
        windowIndex: number | BN | string;
        amount: number | BN | string;
        accountIndex: number | BN | string;
        account: string;
        merkleProof: string[];
      },
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * This method will only work as intended if all `accountIndex`'s are unique for a given `windowIndex`.         The onus is on the Owner of this contract to submit only valid Merkle roots.
   * Returns True if the claim for `accountIndex` has already been completed for the Merkle root at         `windowIndex`.
   * @param accountIndex account index to check within window index.
   * @param windowIndex merkle root to check.
   */
  isClaimed(
    windowIndex: number | BN | string,
    accountIndex: number | BN | string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<boolean>;

  verifyClaim(
    _claim: {
      windowIndex: number | BN | string;
      amount: number | BN | string;
      accountIndex: number | BN | string;
      account: string;
      merkleProof: string[];
    },
    txDetails?: Truffle.TransactionDetails
  ): Promise<boolean>;

  methods: {
    merkleWindows(
      arg0: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{ 0: string; 1: string; 2: string }>;

    nextCreatedIndex(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    /**
     * Returns the address of the current owner.
     */
    owner(txDetails?: Truffle.TransactionDetails): Promise<string>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership: {
      (txDetails?: Truffle.TransactionDetails): Promise<
        Truffle.TransactionResponse<AllEvents>
      >;
      call(txDetails?: Truffle.TransactionDetails): Promise<void>;
      sendTransaction(txDetails?: Truffle.TransactionDetails): Promise<string>;
      estimateGas(txDetails?: Truffle.TransactionDetails): Promise<number>;
    };

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership: {
      (newOwner: string, txDetails?: Truffle.TransactionDetails): Promise<
        Truffle.TransactionResponse<AllEvents>
      >;
      call(
        newOwner: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        newOwner: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        newOwner: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Set merkle root for the next available window index and seed allocations.Callable only by owner of this contract. Caller must have approved this contract to transfer      `rewardsToDeposit` amount of `rewardToken` or this call will fail. Importantly, we assume that the      owner of this contract correctly chooses an amount `rewardsToDeposit` that is sufficient to cover all      claims within the `merkleRoot`. Otherwise, a race condition can be created. This situation can occur      because we do not segregate reward balances by window, for code simplicity purposes.      (If `rewardsToDeposit` is purposefully insufficient to payout all claims, then the admin must      subsequently transfer in rewards or the following situation can occur).      Example race situation:          - Window 1 Tree: Owner sets `rewardsToDeposit=100` and insert proofs that give claimant A 50 tokens and            claimant B 51 tokens. The owner has made an error by not setting the `rewardsToDeposit` correctly to 101.          - Window 2 Tree: Owner sets `rewardsToDeposit=1` and insert proofs that give claimant A 1 token. The owner            correctly set `rewardsToDeposit` this time.          - At this point contract owns 100 + 1 = 101 tokens. Now, imagine the following sequence:              (1) Claimant A claims 50 tokens for Window 1, contract now has 101 - 50 = 51 tokens.              (2) Claimant B claims 51 tokens for Window 1, contract now has 51 - 51 = 0 tokens.              (3) Claimant A tries to claim 1 token for Window 2 but fails because contract has 0 tokens.          - In summary, the contract owner created a race for step(2) and step(3) in which the first claim would            succeed and the second claim would fail, even though both claimants would expect their claims to succeed.
     * @param ipfsHash hash of IPFS object, conveniently stored for clients
     * @param merkleRoot merkle root describing allocation.
     * @param rewardToken ERC20 reward token.
     * @param rewardsToDeposit amount of rewards to deposit to seed this allocation.
     */
    setWindow: {
      (
        rewardsToDeposit: number | BN | string,
        rewardToken: string,
        merkleRoot: string,
        ipfsHash: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        rewardsToDeposit: number | BN | string,
        rewardToken: string,
        merkleRoot: string,
        ipfsHash: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        rewardsToDeposit: number | BN | string,
        rewardToken: string,
        merkleRoot: string,
        ipfsHash: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        rewardsToDeposit: number | BN | string,
        rewardToken: string,
        merkleRoot: string,
        ipfsHash: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Callable only by owner. Likely to be followed by a withdrawRewards call to clear contract state.
     * Delete merkle root at window index.
     * @param windowIndex merkle root index to delete.
     */
    deleteWindow: {
      (
        windowIndex: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        windowIndex: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        windowIndex: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        windowIndex: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Callable only by owner.
     * Emergency method that transfers rewards out of the contract if the contract was configured improperly.
     * @param amount amount of rewards to withdraw.
     * @param rewardCurrency rewards to withdraw from contract.
     */
    withdrawRewards: {
      (
        rewardCurrency: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        rewardCurrency: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        rewardCurrency: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        rewardCurrency: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    claimMulti: {
      (
        claims: {
          windowIndex: number | BN | string;
          amount: number | BN | string;
          accountIndex: number | BN | string;
          account: string;
          merkleProof: string[];
        }[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        claims: {
          windowIndex: number | BN | string;
          amount: number | BN | string;
          accountIndex: number | BN | string;
          account: string;
          merkleProof: string[];
        }[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        claims: {
          windowIndex: number | BN | string;
          amount: number | BN | string;
          accountIndex: number | BN | string;
          account: string;
          merkleProof: string[];
        }[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        claims: {
          windowIndex: number | BN | string;
          amount: number | BN | string;
          accountIndex: number | BN | string;
          account: string;
          merkleProof: string[];
        }[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    claim: {
      (
        _claim: {
          windowIndex: number | BN | string;
          amount: number | BN | string;
          accountIndex: number | BN | string;
          account: string;
          merkleProof: string[];
        },
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        _claim: {
          windowIndex: number | BN | string;
          amount: number | BN | string;
          accountIndex: number | BN | string;
          account: string;
          merkleProof: string[];
        },
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        _claim: {
          windowIndex: number | BN | string;
          amount: number | BN | string;
          accountIndex: number | BN | string;
          account: string;
          merkleProof: string[];
        },
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        _claim: {
          windowIndex: number | BN | string;
          amount: number | BN | string;
          accountIndex: number | BN | string;
          account: string;
          merkleProof: string[];
        },
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * This method will only work as intended if all `accountIndex`'s are unique for a given `windowIndex`.         The onus is on the Owner of this contract to submit only valid Merkle roots.
     * Returns True if the claim for `accountIndex` has already been completed for the Merkle root at         `windowIndex`.
     * @param accountIndex account index to check within window index.
     * @param windowIndex merkle root to check.
     */
    isClaimed(
      windowIndex: number | BN | string,
      accountIndex: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<boolean>;

    verifyClaim(
      _claim: {
        windowIndex: number | BN | string;
        amount: number | BN | string;
        accountIndex: number | BN | string;
        account: string;
        merkleProof: string[];
      },
      txDetails?: Truffle.TransactionDetails
    ): Promise<boolean>;
  };

  getPastEvents(event: string): Promise<EventData[]>;
  getPastEvents(
    event: string,
    options: PastEventOptions,
    callback: (error: Error, event: EventData) => void
  ): Promise<EventData[]>;
  getPastEvents(event: string, options: PastEventOptions): Promise<EventData[]>;
  getPastEvents(
    event: string,
    callback: (error: Error, event: EventData) => void
  ): Promise<EventData[]>;
}
